import { Component } from '@angular/core';
import { NavController, NavParams } from 'ionic-angular';
import{CpluskonuPage} from'../cpluskonu/cpluskonu';
/**
 * Generated class for the CpluslistePage page.
 *
 * See https://ionicframework.com/docs/components/#navigation for more info on
 * Ionic pages and navigation.
 */

@Component({
  selector: 'page-cplusliste',
  templateUrl: 'cplusliste.html',
})
export class CpluslistePage {
  public items2:any;
  public cpluskonu:string;
  constructor(public navCtrl: NavController, public navParams: NavParams) {
    this.items2=[
    {
        cpluskonu:"C++ Nedir ?",
        cplusicerik:"C’yi kapsayan ve çok paradigmalı, yaygın olarak kullanılan, genel amaçlı bir programlama dilidir. C++ geliştirilmesinden sonra tüm dünyada en yaygın kullanılan programlama dillerinden biri olmuştur. Özellikle söz konusu performans olduğunda C++ daima ilk seçim olmaktadır zira diğer programlama dilleriyle kıyaslandığında C++ çok daha fazla güncellenen bir yazılım dilidir. C++ yazılım dili kullanılarak geliştiriciler tarafından sistem yazılımları, özel yazılımlar, uygulamalar, sürücü yazılımları, kullanıcı taraflı yazılımlar ve gömülü firmware yazılımlar üretilmektedir.  Bugün bilgisayarınızda kullanmakta olduğunuz birçok donanımın dahi sürücüsü C++ programlama dili sayesinde hazırlanmış ve son kullanıcıların kullanımına tahsis edilmiştir.C++’da ilk mini yazılımınızı yapmak ve ekrana “Hello World” çıktısını almak içinse aşağıdaki kod betiğini kullanabilirsiniz;#include <iostream>int main(){ std::cout <<'Hello, world!n';}",
        component:CpluskonuPage
     },
    {
      cpluskonu:"C++ Veri Tipleri",
      cplusicerik:"Değişken isimlerini verirken C++'ın bir takım sıkı kurallarına uymamız gerekir. Bu kurallar:**Değişkenlerin isimleri alfabede bulunan karakterlerle başlamalı. Ama ilk harf hariç diğer karakterler sayı olabilir.**C++ büyük ve küçük harf duyarlıdır. Yani Sayi, sayi ve SAYI hepsi ayrı değişken olarak algınalırlar.**Değişken isimleri birden fazla kelime olduğu zaman; kelimelerin arasına boşluk konmaz. Bu tür değişkenleri ya kelimeleri birleştirerek veya kelimeler arasına _ (alt çizgi) karakteri koyararak isimlendiririz.**Değişkenlerin isimleri !, ?, {, ] gibi karakterler içeremezler.**C++'ın anahtar kelimelerini de değişken isimleri olarak kullanamayız.char: 1 bayt dır .Karakter veri tipidir.short:16 bit uzunluğunda tamsayı.long:32 bit uzunluğunda tamsayı.int:4 bayt dır.Tamsayı tipidir.float:Kesirli sayı.double:Geniş ve fazla duyarlıklı kesirli sayı.long double :double tipinin daha genişidir.bool:true(doğru) veya false(yanlış) değerini alır.Yukarıdaki kurala uygun olarak aşağıda bununla ilgili örnekler vardır:int sayi;char karakter;float sayi_2;bool dogru_yanlis; Değişkenlere değer atama işlemi için eşittir (=) operatörünü kullanırız. int x=5; double y=3.22;Değişkenlerin değerlerini ilk tanımladığımız anda da atayabiliriz. Aşağıda bununla ilgili örnekler verelim:double t=3.25;bool dogru_mu=false;long int s1=12345, s2=-694312978425;double t=3.25;",
      component:CpluskonuPage
    },  
    {
      cpluskonu:"C++ Temel Kavramlar" ,
      cplusicerik:"C++ ile kullanıcıdan sırasıyla iki adet sayı girmesini ve bu iki adet değişkende saklıyoruz . Bu değişkenler sayi1 ve sayi2 olarak belirliyoruz . Daha sonra kullanıcının girdiği sayıları topluyoruz ve ekrana yazdırıyoruz . Cin komutu yazıldığında kullanıcıdan sayı girilmesini isteyecektir.Cout ise ekrana verileri yazdırmak için kullanılır.Her seferinde cout ve cin başına std yazmak yerine 'using namespace std; ' global olarak programa eklenir ve std yazılmaz.#include <iostream> using namespace std;int main(int argc, char** argv) { int sayi1,sayi2;cout << 'Lutfen birinci sayiyi giriniz:';cin >> sayi1;cout << 'lutfen ikinci sayiyi giriniz:';cin >> sayi2; // yada cin >> sayi1>> sayi2;int toplam = sayi1+ sayi2; cout << 'Toplam:'<< toplam; }",
      component:CpluskonuPage
     },
    {
      cpluskonu:"Arttırma Ve Azaltma işlemleri",
      cplusicerik:"Csharpta sayısal bir değerden 1 çıkarmak veya sayısal bir değere 1 eklemek için kullanılan iki operatör mevcuttur. Bunlar ++ ve — operatörleridir. ++ toplama işlemi için kullanılırken, — operatörü çıkarma işlemi için kullanılır. Aslında biz buna toplama ve çıkarme demeyelim yine başlıkta olduğu gibi arttırma ve azaltma diyelim.Örneğin sayi adında bir değişkenimiz olsun. Bu sayi değişkenini 1 arttırmak için aşağıdaki gibi kodlar yazabiliriz. 'sayi = sayi + 1; sayi += 1; sayi++;'Bizim bu yazımızda bahsettiğimiz 3. örnekte olduğu gibidir. Tabi bu kullanımlarda dikkat etmemiz gereken bir takım durumlar var. ++ ve — operatörleri bir değişkenin önünde veya ardında yer alabilir. Yani prefix veya postfix olarak kullanılabilir. Ne demek bu, örnekleyelim. İlk kullanım postfix ikinci kullanım ise prefixtir.1.)sayi++; 2.)++sayi;Aynı şekilde — operatörü de kullanılabilir;'1.)sayi--; 2.)--sayi; ' Yine ilk kullanım postfix ikinci kullanım ise prefixtir. Peki farkı nedir? Bu sayi değişkenimizi uygulamamız içinde kullandığımızı farzedelim. Eğer postfix kullanıyorsak öncelikle sayi değerini 1 arttırırız ve daha sonra uygulamamızda bu arttırılmış değeri kullanırız. Eğer prefix kullanıyorsak önce değerimizi uygulamamızda kullanırız ve ardından 1 arttırırız.",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Döngüler Ve Koşul İfadeleri",
      cplusicerik:"IF -ELSE KOMUTU:if-else komutu iki islemden hangisinin uygulanacagina karar verir. Else kismi seçimlidir, gerekmiyorsa kullanilmayabilir. Yazilim kurali ile söyledir.if ( ifade)komut1;else komut2; Daha genel sekliyle; if ( ifade ) {komut1;komut2;...}else {komut1;komut2;...}.SWITCH-CASE KOMUTU:Switch Case deyimi islev bakimindan if deyimine çok benzemektedir. Çok sayida if islem bloklari kullandigimizda programin okunurlugu azalacak ve programi izlemek zorlasacaktir. Programimizin bir degerini bir çok degerle karsilastirmak gerektiginde switch komutunu kullanacagiz. Switch seçenegi ile degiskenin durumuna göre bir çok durum içersinden bir tanesi gerçeklestirilir.switch( Kontrol Degiskeni ){case Sabit1 : komut1; break; case Sabit2 : komut2; break; ...default : Komutson;}WHILE DÖNGÜSÜ:Içlerinde anlatimi ve anlasilmasi en kolay olan döngüdür. While döngüsü, döngü sayisinin belli olmadigi zamanlarda kullanilir. while ( kosul ) Komut;While döngüsü, içinde bulunan ifade dogru oldugu sürece altindaki komut veya komut blogu yürütülür. Eger yanlis ise kontrol bir sonraki komut veya komut bloguna geçer.While döngüsü daha genel sekliyle:while ( ifade ){komut;komut;komut;...}.Burada bir seye dikkat etmenizi istiyorum. Çoklu komutlar kullandigimizda ' { } ' parantezleri gereklidir.DO - WHILE DÖNGÜSÜ:Bu döngü while döngüsünün biraz degistirilmis halidir. Do-while döngüsünde karsilastirma islemi, döngünün sonunda gerçeklesir. Bunun sonucu olarak döngünün içine en az bir defa girilmis olur. Yapisi asagidaki gibidir.do cümle while ( kosul ); do'' nun altindaki cümle kismindaki komut satirlari birden fazla olursa diger döngülerde oldugu gibi '{ }' içine aliyoruz. Bunu kullanmamiz kodlari okuma da ve ayirma da daha çok isimize yarayacaktir.do{cümle cümle cümle ...}while ( kosul );Simdi yukarida demek istedigimizi standart kod satiri üzerinde anlatalim. Kodlari yazdigimizda, komut sirasi do''ya geldigi zaman, do'' dan sonraki komutun döngünün basi oldugunu belirtiyor. Digerlerinden farkli ( for, While ) olarak döngüye giris yapiyor, yani hiçbir kontrol yapmadan en az bir defa döngünün içine girmis oluyoruz.FOR DÖNGÜSÜ:For döngüsünün çalismasi, döngünün kontrol degiskenine baslangiç degerinin atanmasi ile baslar. Asagida verecegimiz ilk deger atama cümlesinden kastimizda budur. Yani bu kisimda baslangiç tanimlari yapilir. For döngüsünün baslangiç adimidir. Bu kisimda yapilan bir degisken tanimindaki degiskenin ömrü, for döngüsünün sonunda biter. Genel yapisi:for ( ilk deger atamalar, kosul, arttirma){cümle1 cümle2 cümle3...} ",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Fonksiyonlar",
      cplusicerik:"Fonksiyon Nedir? Örnegin, y=F(x) fonksiyonu; Bu matematiksel fonksiyon parametre olarak aldinan deger üzerinde bir islem gerçeklestirip, bir sonuç degerini döndürür. Mesela F(x)=x^3+5 seklinde bir fonksiyonumuz olsun, x=2 için F(x)=13 olur. Burada x fonksiyonun parametresi, 13 ise fonksiyonun geri döndürdügü degerdir. Simdi de bu matematiksel ifadeyi kodlarimizla yorumlayalim.'Int x;x=F(2,5)//buradan da 'int f(2,5) 'gibi görebiliriz... Dikkat edersek ikinci satirda, daha önce islemedigimiz bir kod var. Int x, F(2,5) degerine esitlenmistir. Simdi bir fonksiyonun nasil yazildiginin kalibini çikartabiliriz.<Döndürdügü deger> <Fonksiyonun adi> ( <parametre listesi> ) {<ifadeler>}'.Buradaki parantezlere ve küme isaretlerine dikkat ediniz. Simdi yukarda yazdigimiz kalibi biraz açalim.<Döndürdügü deger> : Fonksiyon her hangi bir tipte deger döndürebilir. Bu bilesen fonksiyonun döndürecegi degerin tipini ifade eder. (örnegin, int, dounle, float v.s v.s )<Fonksiyonun adi> : Yapmak istedigimiz islemin adidir. Örnegin bir asal sayi fonksiyonu yazacagiz. Burada yazacagimiz fonksiyonun adini belirtiyoruz. Benim size tavsiyem AsalSayi veya asal_sayi seklinde kullanmanizdir. Okunabilirlik açisindan size avantaj saglayacaktir.<parametre listesi> : Fonksiyonun kullanacaga parametrelerin tipleri ile siralanir. Örnegin, FonksiyonAdi(int x, double y) gibi.<ifadeler> : Fonksiyonun kullanacagi tanimlamalar ve kodlardan olusan kisimdir. Nasil biz main() { kodlar } seklinde kullaniyorsak. Bunu da ona benzetebiliriz. Ama main() i bunlarla karıştirmayiniz.",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Diziler Ve Pointerlar",
      cplusicerik:"Diziler,'indisleri olan degiskenler' olarak adlandirilirlar. Diger bir deyisle, birden fazla tek düze veri tipi içeren degiskenlerdir. Diziler birbirine bitisik bellek gözleri kullanilarak olusturulurlar.Not: For döngüsü dizi elemanlarina ulasmak için en çok kullanilan yöntemdir.Dizilerin indislerden olustugunu söylemistik. Diger yüksek seviyeli dillerle karsilastirildiginda arasindaki fark ilk elemanin indisi daima sifir (0) olmasidir.Bir dizi tanimlayicisi -adi-, dizinin ilk elemaninin adresini tanimlayan adrestir. Bunu söyle izah edelim; elimizde bir dizi var ve ilk elemani karakter ise biz 'char DiziAdi[boyut]' seklinde tanimlariz. Tam sayi ise 'int DiziAdi[boyut]' seklinde olur.Dizilerin Tanimlanmasi ve Deger Atama:Int a[10]; Seklinde bir diziyi tanimlayabiliriz. Bunu daha genel bir kaliba dökersek.<tip> <dizi adi> [<boyut>]; halini alir. Birde boyutlarinin arttirilmis halini verelim.<tip> <dizi adi> [<boyut1>][<boyut2>][<boyut3>]....[<boyutn>]; n boyutlu dizi:).<--POİNTER GİRİŞ--> Isaretçiler (Pointers) ve bundan önce görmüs oldugumuz diziler (Arrays) ilerde yapacagimiz uygulamalarda kullanimina kesin ihtiyaç duyacagimiz basliklardir. Bunlar bize dinamik bellek kullanimini saglarlar. Dinamik bellek kullanimindan bahsedecek olursak, bellegimizin kutucuklardan olustugunu hayal edin. 100 kutucuklu bir bellegimiz var. Bu kutucuklarin her birinin bir adresi vardir ve biz de bu adresler yolu ile kutucuklara erisiriz. Iste isaretçiler bu erisimi sagliyor. Isaretçilerin Tanimlanmasi ve Deger Atanmasi:Bir isaretçi tipi, hangi tipe isaret ettigini belirten ve birer adres degeri içeren verilere sahiptir. Bir isaretçi degisken bildirimi, açik olarak hangi tip veriyi kullanacagini bildirerek baslar. Derleyicimizde * isareti ile isaretçi degiskeni tanimladigimizi anlar.<tip> *<isaretçi adi>; Seklinde yazilir. Örnegin, int *IsaretciAdi; Simdi de ayni satirda birden fazla isaretçi tanimlayalim. Int *is1, *is2, *is3; Seklinde tanimlayabiliriz.'&' adres operatörü, kendisisinden sonra gelen ifadenin adresini gösterir.'int sayi;int *psayi;cout<<'sayi girinz:'; cin>>sayi; psayi=&sayi; cout<<'sayi:'<<sayi<<endl; cout<<,'sayinin adresi :'<<&sayi<<endl;'",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Strcut Yapısı",
      cplusicerik:"Yapı (Struct) : Birbirleriyle ilişkili değişkenlerin, bir isim altında toplanmasına yapı adı verilir. Yapılar, değişik veri tiplerinde elemanlar içerebilirler ve dosya içinde tutulacak kayıtları oluşturmakta kullanılırlar.Yapılar, diğer tipte nesneler kullanılarak oluşturulan, türetilmiş veri tipleridir. Örnek bir yapı şu şekilde oluşturulabilir.struct ogrenci{public char ad ; public char soyad ; public long no; public short sinif;}Structlar, global olarak tanımlanmalıdır.Struct ‘ ın içindeki değişkenler member yani üye olarak adlandırılır. Buradaki ad, soyad, no, sinif ogrenci struct’ının üyeleridir.ogrenci struct'ının üyelerine doğrudan erişim sağlayamayız.ogrencinin üyelerine ogrenci struct'ından bir obje oluşturarak üyelerine erişebiliriz.Üyelere erişmek için dot(nokta) operatörü kullanılır.ogrenci struct'ının üyelerine doğrudan erişim sağlayamayız.ogrencinin üyelerine ogrenci struct'ından bir obje oluşturarak üyelerine erişebiliriz.Objemizi oluşturalım : ogrenci ogr; ogr.ad='Ayşe'; ogr.no='123' gibi ulaşılır",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Class Yapısı",
      cplusicerik:"Nesneye dayalı programlamanın temelinde sınıf yapısı vardır. Re-usable code ( yeniden kullanılabilir kod ) yazmak için sınıflar kullanılır.Class, yapı olarak struct a benzer . Struct ‘ın daha gelişmiş versiyonu olarak düşünülebilir. Struct’tan farklı olarak sınıflar aynı yapının üzerinde çalışacak fonksiyonlar içerir.Örnek class yapısı:class DayOfYear {public:void output();// member functionint month;int day;};Declaring Objects ( Nesne Tanımlama / İfade Etme): DayOfYear today, birthday; Bu objeler, data(veri) ve operasyon (member fonksiyon) içerir. Yukarıdaki örnekteki datalar month ve day , operasyon ise output() fonksiyonudur.Class Member Access ( Sınıfın Üyelerine Erişme ):Tıpkı struct’taki gibi dot operatörü kullanılarak erişilebilir.today.month; today.day; today.output();Class Member Functions ( Sınıfın Member Fonksiyonları ):Diğer fonksiyonlara benzer şekilde main ‘den sonra tanımlanmalıdır.void DayOfYear::output()  //DayOfYear'a ait olduğunu belirtmek için{…  //burada member fonksiyonda yapılmak istenenler yer almalı.}",
      component:CpluskonuPage
     },
     {
      cpluskonu:"Yapıcı Ve Yıkıcı Fonksiyonlar",
      cplusicerik:"Yapıcı fonksiyonlar(Constructor), bulundukları class ile aynı isimli olurlar.Bir sınıftan nesne oluşturulduğu zaman o classın yapıcı fonksiyonu çalışır.Main fonksiyonundan hangi yapıcı fonksiyonu çağırırsak o fonksiyondaki işlemler yapılacaktır.Yapıcı fonksiyonlar parametre döndürmezler.Diğer fonksiyonları private yapabiliyorken yapıcı fonksiyonlar public erişime sahiptirler.Örnekte yapıcı fonksiyonu görelim.class deneme {public:deneme();//yapıcı fonksiyon}; deneme::deneme() {cout << 'YApici Fonksiyon Calisti!!'<< endl;}int main(){ deneme d;system('PAUSE');return 0;} .Yapıcı fonksiyonu oluştururken classa ait olduğunu başta class adı ::’dan sonra yapıcı fonksiyonumuzu adını yazarak oluştururuz.Bir classta parametresiz ile bir veya birden fazla parametreli birden fazla yapıcı fonksiyon bulunabilir.Birden fazla yapıcı fonksiyon kullanıldığı zaman aşırı yüklenme olur.class deneme {public:deneme(int, int);};deneme::deneme(int x, int y){cout << 'Iki Parametreli Yapici Fonksiyon Cagirildi!'<< endl;}int main(){deneme d2(6, 1);system('PAUSE');return 0;}.Yıkıcı fonksiyonlar(Deconstructor),yapıcı fonksiyonlar gibi bulundukları class ile aynı isimlidirler.Class ile işlemler bittiği zaman gereken işlemleri içeren fonksiyonlardır.Yapıcı fonksiyonların başında tilda(~) karakteri bulunur.Nesne  silineceği zaman yıkıcı fonksiyon çağırılır.Yıkıcı fonksiyon çağırıldığında bellek nesnenin yeri silinir ve yeni oluşacak nesne için yer açılır.Yıkıcı fonksiyonlarda parametre bulunmaz.Yıkıcı fonksiyonlar değer döndürmezler.Bir sınıfa ait bir yıkıcı fonksiyon olabilir.Yıkıcı fonksiyonlarda aşırı yüklenme olmaz.class deneme {public:deneme();//parametresiz yapıcı fonksiyon ~deneme();};deneme::deneme() {cout << 'Parametresiz Yapici Fonksiyon Calisti!' << endl;}deneme::~deneme(){delete[];cout << 'Yikici Fonksiyon Cagirildi!' << endl;}int main(){deneme d;deneme d1(4);system('PAUSE');return 0;}",
      component:CpluskonuPage
     },
   
     {
      cpluskonu:"Kalıtım Giriş",
      cplusicerik:"Nesneye dayalı programların en önemli konularından kalıtımdır.Kalıtım,temel bir sınıftan yeni bir sınıf türetilir.Kalıtım, programın işlevselliğini ve hızlı uygulamayı yeniden kullanma fırsatı verir..Bir sınıfı oluşturduğumuz zaman yeniden değişkenler ve fonksiyonlar yazmak yerine olan bir sınıftan kalıtım ile kullanmak istediği değişken veya fınksiyonları kullanabilir.Genel Kullanımı:class türetilmiş sınıf : Erişim türü Temel sınıf{};Böylece türetilmiş sınıf temel sınıftan kalıtım yapmış oldu.Temel sınıfın içerisinde public veya protected olarak tanımlanan tüm fonkdiyon ve değişkenlere ulaşıp üzerinde işlem yapabilir.Temel sınıftan türetilmiş olan bir sınıf dahi olsa,temel sınıfımızda private olarak tanımladığınan fonksiyon ve değişkenlere erişim mümkün değildir.Private olarak tanımlanan değerler sadece bulundukları sınıflarda kullanılabilir.class temel {public:string ad,soyad;int yas;void sorgu(){cout << 'Adiniz = \n';cin >> ad;cout << 'Yasiniz = '<< endl;cin >> yas;}};class turetilmis :public temel{	};int main(){turetilmis t;t.sorgu();system('Pause');return 0;}",
      component:CpluskonuPage
     }
    ]
  }
cpluskonusayfa(sayfa4){
    this.navCtrl.push(CpluskonuPage,{
      data4:sayfa4 })
}
}
